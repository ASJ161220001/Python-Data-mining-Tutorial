# Python基础算法案例：24点纸牌游戏算法

> **作者**：长行
>
> **时间**：2020.05.14

## 目标要求
对于任意给定的四张扑克牌，计算是否有赢得24点游戏的方法（即使用加、减、乘、除四则运算凑成24的方法）；如果有的话，列出所有可能的方法。

> **【24点游戏规则】**
>
> 在大小王以外的52张牌中，任意抽取其中4张牌。如果通过加、减、乘、除四则运算（可加括号）的方法，将抽到的4张牌算成24，则为胜利；每张牌都必须使用，且只能使用一次。

## 第一种解法

依据游戏规则，我们可以想到如下解决思路：使用枚举的方法，将所有的计算方法都枚举出来，将四张扑克牌的数字代入到所有的计算方法中得出结果，如果结果为24则为解。

由此，我们得到了第一种解法。在具体实现中：将所有可能的四则运算组合和所有可能的括号组合合并在一起，由此生成所有可能的算式组合。计算某一个牌组时，先计算所有该牌组所有可能的组合方式，并将所有的组合方式带入所有可能的算式组合求解。

```python
import itertools

class CardGaming:
    def __init__(self):
        self.formula_list = list()  # 存储所有可能的算式
        for marks in itertools.product(["+", "-", "*", "/"], repeat=3):
            for bracket in ["{0}%s{1}%s{2}%s{3}", "({0}%s{1})%s{2}%s{3}", "({0}%s{1}%s{2})%s{3}",
                            "{0}%s({1}%s{2})%s{3}",
                            "{0}%s({1}%s{2}%s{3})", "({0}%s{1})%s({2}%s{3})", "{0}%s{1}%s({2}%s{3})"]:
                self.formula_list.append((bracket % marks))

    def solve(self, card_probability):
        answer = []
        for card_order in set(itertools.permutations(card_probability, 4)):  # 遍历所有可能的不同卡牌顺序（最多24种可能）
            for formula in self.formula_list:  # 遍历所有可能的算式（448种可能）
                final_formula = formula.format(*card_order)
                try:
                    if round(eval(final_formula), 3) == 24:
                        answer.append(final_formula)
                except ZeroDivisionError:
                    continue
        return answer

if __name__ == "__main__":
    print(CardGaming().solve((3, 3, 8, 8)))  # 输出: 8/(3-8/3)
```

当前代码在计算每一个牌组的答案时，都需要遍历$4^3\times{7}=448$种算式和最多$A^4_4=24$种卡牌顺序，即处理最多$448\times{24}=10752$种可能性。使用这个解法计算所有可能的扑克牌组合（共计$13^4=28561$种解法），需要1906秒(I7 7700,8GB)。

* 因为

## 第二种解法

在第一种解法中，计算每一个牌组的答案时，处理的可能性中有很多重复的情况，例如“A+B-C+D”、“D-C+B+A”、“D+A-C+B“等。这就极大地拖累了我们的运算速度。但是，要在第一种解法的基础上来合并这些不同的情况，需要同时考虑符号、括号和卡牌顺序，十分复杂。

因此，我们可以从另外一个角度来解决这个问题。

通过观察我们可以发现，无论什么算式，本质上都是按着一定的顺序，对4张扑克牌的数值进行三次运算；而每一次运算，都是从尚未用过的扑克牌以及之前的运算结果中选择2个进行运算。所以，我们可以将所有算式归纳为：

从4张牌中任意抽取2个进行任意运算，将未抽取的2张牌和运算结果组合成包含3个数值的新列表；在新列表中任意抽取2个进行任意运算，将未抽取的1张牌和运算结果组成包含2个数值的新列表；对新列表中的2个数值进行任意运算得出结果，如果结果为24则为解。

由此，我们得到了第二种算法。在具体实现中，我们主要注意如下几点：

* 因为不再枚举算式，所以我们也不再需要使用低效的```eval()```函数运行算式。
* 因为如果在运算过程中生成算式，会增加很多运算量，所以我们只在求出解后反向生成解的算式（哪怕这样生成算式会更困难，但是需要生成的次数大大减少）。

```python
import itertools

if __name__ == "__main__":
    card_probability = [3, 3, 8, 8]  # 定义需要解决的牌组

    for combine_1 in set(itertools.permutations(card_probability, 2)):  # 在A1、A2、A3、A4四张扑克牌中任意抽取两张
        for mark_1 in ["%f+%f", "%f-%f", "%f*%f", "%f/%f"]:
            try:
                card_list_1 = copy.deepcopy(card_probability)
                card_list_1.remove(combine_1[0])  # 移除抽取的扑克牌
                card_list_1.remove(combine_1[1])  # 移除抽取的扑克牌
                card_list_1.append(eval(mark_1 % combine_1))  # 添加抽取两张牌的计算结果
                for combine_2 in set(itertools.permutations(card_list_1, 2)):  # 在B1、B2、B3中抽取任意两个数
                    for mark_2 in ["%f+%f", "%f-%f", "%f*%f", "%f/%f"]:
                        try:
                            card_list_2 = copy.deepcopy(card_list_1)
                            card_list_2.remove(combine_2[0])  # 移除抽取的数字
                            card_list_2.remove(combine_2[1])  # 移除抽取的数字
                            card_list_2.append(eval(mark_2 % combine_2))  # 添加抽取数字的计算结果
                            for combine_3 in set(itertools.permutations(card_list_2, 2)):  # 在B1、B2、B3中抽取任意两个数
                                for mark_3 in ["%f+%f", "%f-%f", "%f*%f", "%f/%f"]:
                                    try:
                                        result = eval(mark_3 % combine_3)  # 计算最终结果
                                        if round(result, 3) == 24:
                                            print(mark_1 % combine_1, "→", mark_2 % combine_2, "→", mark_3 % combine_3)
                                    except ZeroDivisionError:
                                        continue
                        except ZeroDivisionError:
                            continue
            except ZeroDivisionError:
                continue
```

运行结果：

```
8.000000/3.000000 → 3.000000-2.666667 → 8.000000/0.333333
```

这种方法在第一次四则运算时，有$A^2_4=12$种抽取结果，有4种运算结果；在第二次四则运算时，有$A^2_3=6$种抽取结果，有4种运算结果；在第三次四则运算时，有$A^2_2=2$种抽取结果，有4种运算结果。因此，最多需要考虑${A^2_4}\times{A^2_3}\times{A^2_2}\times{4^3}=9216$种可能性。



